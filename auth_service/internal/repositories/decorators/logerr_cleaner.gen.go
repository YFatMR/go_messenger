// Code generated by gowrap. DO NOT EDIT.
// template: ../../../../core/pkg/decorators/templates/logerr_cleaner.go
// gowrap: http://github.com/hexdigest/gowrap

package decorators

//go:generate gowrap gen -p github.com/YFatMR/go_messenger/auth_service/internal/repositories -i AccountRepository -t ../../../../core/pkg/decorators/templates/logerr_cleaner.go -o logerr_cleaner.gen.go -l ""

import (
	"context"

	"github.com/YFatMR/go_messenger/auth_service/internal/entities"
	"github.com/YFatMR/go_messenger/auth_service/internal/entities/accountid"
	"github.com/YFatMR/go_messenger/auth_service/internal/entities/credential"
	"github.com/YFatMR/go_messenger/auth_service/internal/entities/tokenpayload"
	"github.com/YFatMR/go_messenger/auth_service/internal/repositories"
	"github.com/YFatMR/go_messenger/core/pkg/errors/logerr"
)

// LogerrCleanerAccountRepositoryDecorator implements repositories.AccountRepository
// Use LogerrCleanerAccountRepositoryDecorator to make logerr.Error nil if it has no error
// Use LogerrCleanerAccountRepositoryDecorator as last decorator in your chain
type LogerrCleanerAccountRepositoryDecorator struct {
	base repositories.AccountRepository
}

// NewLogerrCleanerAccountRepositoryDecorator instruments an implementation of the repositories.AccountRepository with simple logging
func NewLogerrCleanerAccountRepositoryDecorator(base repositories.AccountRepository) *LogerrCleanerAccountRepositoryDecorator {
	if base == nil {
		panic("LogerrCleanerAccountRepositoryDecorator got empty base")
	}
	return &LogerrCleanerAccountRepositoryDecorator{
		base: base,
	}
}

// CreateAccount implements repositories.AccountRepository
func (d *LogerrCleanerAccountRepositoryDecorator) CreateAccount(ctx context.Context, credential *credential.Entity, role entities.Role) (accountID *accountid.Entity, lerr logerr.Error) {

	if lerr != nil && !lerr.HasError() {
		lerr = nil
	}
	return d.base.CreateAccount(ctx, credential, role)
}

// GetTokenPayloadWithHashedPasswordByLogin implements repositories.AccountRepository
func (d *LogerrCleanerAccountRepositoryDecorator) GetTokenPayloadWithHashedPasswordByLogin(ctx context.Context, login string) (tokenPayload *tokenpayload.Entity, hashedPassword string, lerr logerr.Error) {

	if lerr != nil && !lerr.HasError() {
		lerr = nil
	}
	return d.base.GetTokenPayloadWithHashedPasswordByLogin(ctx, login)
}
