// Code generated by gowrap. DO NOT EDIT.
// template: ../../../../core/pkg/decorators/templates/opentelemetry_tracing.go
// gowrap: http://github.com/hexdigest/gowrap

package decorators

//go:generate gowrap gen -p github.com/YFatMR/go_messenger/auth_service/internal/services -i AccountService -t ../../../../core/pkg/decorators/templates/opentelemetry_tracing.go -o opentelemetry_tracing.gen.go -l ""

import (
	"context"

	"github.com/YFatMR/go_messenger/auth_service/internal/entities/accountid"
	"github.com/YFatMR/go_messenger/auth_service/internal/entities/credential"
	"github.com/YFatMR/go_messenger/auth_service/internal/entities/token"
	"github.com/YFatMR/go_messenger/auth_service/internal/entities/tokenpayload"
	"github.com/YFatMR/go_messenger/auth_service/internal/services"
	"github.com/YFatMR/go_messenger/core/pkg/errors/logerr"
	"go.opentelemetry.io/otel/trace"
)

// OpentelemetryTracingAccountServiceDecorator implements services.AccountService that is instrumented with custom zap logger
type OpentelemetryTracingAccountServiceDecorator struct {
	base         services.AccountService
	tracer       trace.Tracer
	recordErrors bool
}

// NewOpentelemetryTracingAccountServiceDecorator instruments an implementation of the services.AccountService with simple logging
func NewOpentelemetryTracingAccountServiceDecorator(base services.AccountService, tracer trace.Tracer, recordErrors bool) *OpentelemetryTracingAccountServiceDecorator {
	if base == nil {
		panic("OpentelemetryTracingAccountServiceDecorator got empty base")
	}
	if tracer == nil {
		panic("OpentelemetryTracingAccountServiceDecorator got empty tracer")
	}
	return &OpentelemetryTracingAccountServiceDecorator{
		base:         base,
		tracer:       tracer,
		recordErrors: recordErrors,
	}
}

// CreateAccount implements services.AccountService
func (d *OpentelemetryTracingAccountServiceDecorator) CreateAccount(ctx context.Context, credential *credential.Entity) (accountID *accountid.Entity, lerr logerr.Error) {

	var span trace.Span
	ctx, span = d.tracer.Start(ctx, "/CreateAccount")
	defer func() {
		defer span.End()
		if lerr == nil {
			return
		}
		if lerr.HasError() && d.recordErrors {
			span.RecordError(lerr.GetAPIError())
		}
	}()
	return d.base.CreateAccount(ctx, credential)
}

// GetToken implements services.AccountService
func (d *OpentelemetryTracingAccountServiceDecorator) GetToken(ctx context.Context, credential *credential.Entity) (token *token.Entity, lerr logerr.Error) {

	var span trace.Span
	ctx, span = d.tracer.Start(ctx, "/GetToken")
	defer func() {
		defer span.End()
		if lerr == nil {
			return
		}
		if lerr.HasError() && d.recordErrors {
			span.RecordError(lerr.GetAPIError())
		}
	}()
	return d.base.GetToken(ctx, credential)
}

// GetTokenPayload implements services.AccountService
func (d *OpentelemetryTracingAccountServiceDecorator) GetTokenPayload(ctx context.Context, token *token.Entity) (tokenPayload *tokenpayload.Entity, lerr logerr.Error) {

	var span trace.Span
	ctx, span = d.tracer.Start(ctx, "/GetTokenPayload")
	defer func() {
		defer span.End()
		if lerr == nil {
			return
		}
		if lerr.HasError() && d.recordErrors {
			span.RecordError(lerr.GetAPIError())
		}
	}()
	return d.base.GetTokenPayload(ctx, token)
}
