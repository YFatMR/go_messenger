// Code generated by gowrap. DO NOT EDIT.
// template: ../../core/pkg/decorators/templates/czap_logger.template.go
// gowrap: http://github.com/hexdigest/gowrap

package decorator

//go:generate gowrap gen -p github.com/YFatMR/go_messenger/user_service/apientity -i UserRepository -t ../../core/pkg/decorators/templates/czap_logger.template.go -o user_repository_czap_logger.gen.go -l ""

import (
	"context"

	"github.com/YFatMR/go_messenger/core/pkg/czap"
	"github.com/YFatMR/go_messenger/user_service/apientity"
	"github.com/YFatMR/go_messenger/user_service/entity"
	"go.uber.org/zap"
)

// LoggingUserRepositoryDecorator implements apientity.UserRepository that is instrumented with custom zap logger
type LoggingUserRepositoryDecorator struct {
	logger *czap.Logger
	base   apientity.UserRepository
}

// NewLoggingUserRepositoryDecorator instruments an implementation of the apientity.UserRepository with simple logging
func NewLoggingUserRepositoryDecorator(base apientity.UserRepository, logger *czap.Logger) *LoggingUserRepositoryDecorator {
	if base == nil {
		panic("LoggingUserRepositoryDecorator got empty base")
	}
	if logger == nil {
		panic("LoggingUserRepositoryDecorator got empty logger")
	}
	return &LoggingUserRepositoryDecorator{
		base:   base,
		logger: logger,
	}
}

// Create implements apientity.UserRepository
func (d *LoggingUserRepositoryDecorator) Create(ctx context.Context, user *entity.User, credential *entity.Credential) (userID *entity.UserID, err error) {

	d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: calling Create")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: Create finished")
	}()
	return d.base.Create(ctx, user, credential)
}

// DeleteByID implements apientity.UserRepository
func (d *LoggingUserRepositoryDecorator) DeleteByID(ctx context.Context, userID *entity.UserID) (err error) {

	d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: calling DeleteByID")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: DeleteByID finished")
	}()
	return d.base.DeleteByID(ctx, userID)
}

// GetAccountByEmail implements apientity.UserRepository
func (d *LoggingUserRepositoryDecorator) GetAccountByEmail(ctx context.Context, email string) (account *entity.Account, err error) {

	d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: calling GetAccountByEmail")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: GetAccountByEmail finished")
	}()
	return d.base.GetAccountByEmail(ctx, email)
}

// GetByID implements apientity.UserRepository
func (d *LoggingUserRepositoryDecorator) GetByID(ctx context.Context, userID *entity.UserID) (user *entity.User, err error) {

	d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: calling GetByID")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingUserRepositoryDecorator: GetByID finished")
	}()
	return d.base.GetByID(ctx, userID)
}
