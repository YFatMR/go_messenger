// Code generated by gowrap. DO NOT EDIT.
// template: ../../../../core/pkg/decorators/templates/logerror_logger.go
// gowrap: http://github.com/hexdigest/gowrap

package decorators

//go:generate gowrap gen -p github.com/YFatMR/go_messenger/user_service/internal/repositories -i UserRepository -t ../../../../core/pkg/decorators/templates/logerror_logger.go -o logerror_logger.gen.go -l ""

import (
	"context"

	"github.com/YFatMR/go_messenger/core/pkg/errors/logerr"
	"github.com/YFatMR/go_messenger/core/pkg/loggers"
	"github.com/YFatMR/go_messenger/user_service/internal/entities/accountid"
	"github.com/YFatMR/go_messenger/user_service/internal/entities/user"
	"github.com/YFatMR/go_messenger/user_service/internal/entities/userid"
	"github.com/YFatMR/go_messenger/user_service/internal/repositories"
)

// LoggingUserRepositoryDecorator implements repositories.UserRepository that is instrumented with custom zap logger
type LoggingUserRepositoryDecorator struct {
	logger *loggers.OtelZapLoggerWithTraceID
	base   repositories.UserRepository
}

// NewLoggingUserRepositoryDecorator instruments an implementation of the repositories.UserRepository with simple logging
func NewLoggingUserRepositoryDecorator(base repositories.UserRepository, logger *loggers.OtelZapLoggerWithTraceID) *LoggingUserRepositoryDecorator {
	if base == nil {
		panic("LoggingUserRepositoryDecorator got empty base")
	}
	if logger == nil {
		panic("LoggingUserRepositoryDecorator got empty logger")
	}
	return &LoggingUserRepositoryDecorator{
		base:   base,
		logger: logger,
	}
}

// Create implements repositories.UserRepository
func (d *LoggingUserRepositoryDecorator) Create(ctx context.Context, user *user.Entity, accountID *accountid.Entity) (userID *userid.Entity, lerr logerr.Error) {

	d.logger.DebugContextNoExport(ctx, "LoggingUserRepositoryDecorator: calling Create")
	defer func() {
		defer d.logger.DebugContextNoExport(ctx, "LoggingUserRepositoryDecorator: Create finished")
		if lerr == nil {
			return
		}
		if lerr.IsLogMessage() {
			// TODO: create special template for nil error logick
			// If we have no error, make error nil to prevent logging the same message many times
			d.logger.LogContextLogerror(ctx, lerr)
			lerr.StopLogMessage()
		}
		if !lerr.HasError() {
			lerr = nil
		}
	}()
	return d.base.Create(ctx, user, accountID)
}

// DeleteByID implements repositories.UserRepository
func (d *LoggingUserRepositoryDecorator) DeleteByID(ctx context.Context, userID *userid.Entity) (lerr logerr.Error) {

	d.logger.DebugContextNoExport(ctx, "LoggingUserRepositoryDecorator: calling DeleteByID")
	defer func() {
		defer d.logger.DebugContextNoExport(ctx, "LoggingUserRepositoryDecorator: DeleteByID finished")
		if lerr == nil {
			return
		}
		if lerr.IsLogMessage() {
			// TODO: create special template for nil error logick
			// If we have no error, make error nil to prevent logging the same message many times
			d.logger.LogContextLogerror(ctx, lerr)
			lerr.StopLogMessage()
		}
		if !lerr.HasError() {
			lerr = nil
		}
	}()
	return d.base.DeleteByID(ctx, userID)
}

// GetByID implements repositories.UserRepository
func (d *LoggingUserRepositoryDecorator) GetByID(ctx context.Context, userID *userid.Entity) (user *user.Entity, lerr logerr.Error) {

	d.logger.DebugContextNoExport(ctx, "LoggingUserRepositoryDecorator: calling GetByID")
	defer func() {
		defer d.logger.DebugContextNoExport(ctx, "LoggingUserRepositoryDecorator: GetByID finished")
		if lerr == nil {
			return
		}
		if lerr.IsLogMessage() {
			// TODO: create special template for nil error logick
			// If we have no error, make error nil to prevent logging the same message many times
			d.logger.LogContextLogerror(ctx, lerr)
			lerr.StopLogMessage()
		}
		if !lerr.HasError() {
			lerr = nil
		}
	}()
	return d.base.GetByID(ctx, userID)
}
