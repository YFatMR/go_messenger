// Code generated by gowrap. DO NOT EDIT.
// template: ../../core/pkg/decorators/templates/czap_logger.template.go
// gowrap: http://github.com/hexdigest/gowrap

package decorator

//go:generate gowrap gen -p github.com/YFatMR/go_messenger/dialog_service/apientity -i DialogModel -t ../../core/pkg/decorators/templates/czap_logger.template.go -o dialog_model_czap_logger.gen.go -l ""

import (
	"context"

	"github.com/YFatMR/go_messenger/core/pkg/czap"
	"github.com/YFatMR/go_messenger/dialog_service/apientity"
	"github.com/YFatMR/go_messenger/dialog_service/entity"
	"go.uber.org/zap"
)

// LoggingDialogModelDecorator implements apientity.DialogModel that is instrumented with custom zap logger
type LoggingDialogModelDecorator struct {
	logger *czap.Logger
	base   apientity.DialogModel
}

// NewLoggingDialogModelDecorator instruments an implementation of the apientity.DialogModel with simple logging
func NewLoggingDialogModelDecorator(base apientity.DialogModel, logger *czap.Logger) *LoggingDialogModelDecorator {
	if base == nil {
		panic("LoggingDialogModelDecorator got empty base")
	}
	if logger == nil {
		panic("LoggingDialogModelDecorator got empty logger")
	}
	return &LoggingDialogModelDecorator{
		base:   base,
		logger: logger,
	}
}

// CreateDialog implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) CreateDialog(ctx context.Context, userID1 *entity.UserID, userID2 *entity.UserID) (dialog *entity.Dialog, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling CreateDialog")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: CreateDialog finished")
	}()
	return d.base.CreateDialog(ctx, userID1, userID2)
}

// CreateDialogMessage implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) CreateDialogMessage(ctx context.Context, request *entity.CreateDialogMessageRequest) (msg *entity.DialogMessage, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling CreateDialogMessage")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: CreateDialogMessage finished")
	}()
	return d.base.CreateDialogMessage(ctx, request)
}

// CreateDialogMessageWithCode implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) CreateDialogMessageWithCode(ctx context.Context, request *entity.CreateDialogMessageWithCodeRequest) (dp1 *entity.DialogMessage, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling CreateDialogMessageWithCode")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: CreateDialogMessageWithCode finished")
	}()
	return d.base.CreateDialogMessageWithCode(ctx, request)
}

// CreateInstruction implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) CreateInstruction(ctx context.Context, userID *entity.UserID, dialogID *entity.DialogID, instructionTitle string, instructionText string) (instructionID *entity.InstructionID, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling CreateInstruction")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: CreateInstruction finished")
	}()
	return d.base.CreateInstruction(ctx, userID, dialogID, instructionTitle, instructionText)
}

// GetDialog implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) GetDialog(ctx context.Context, userID *entity.UserID, dialogID *entity.DialogID) (dialog *entity.Dialog, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling GetDialog")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: GetDialog finished")
	}()
	return d.base.GetDialog(ctx, userID, dialogID)
}

// GetDialogMessages implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) GetDialogMessages(ctx context.Context, dialogID *entity.DialogID, messageID *entity.MessageID, limit uint64, offsetType entity.DialogMessagesOffserType) (messages []*entity.DialogMessage, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling GetDialogMessages")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: GetDialogMessages finished")
	}()
	return d.base.GetDialogMessages(ctx, dialogID, messageID, limit, offsetType)
}

// GetDialogs implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) GetDialogs(ctx context.Context, userID *entity.UserID, offset uint64, limit uint64) (dialogs []*entity.Dialog, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling GetDialogs")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: GetDialogs finished")
	}()
	return d.base.GetDialogs(ctx, userID, offset, limit)
}

// GetInstructions implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) GetInstructions(ctx context.Context, userID *entity.UserID, dialogID *entity.DialogID, limit uint64) (instructions []*entity.Instruction, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling GetInstructions")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: GetInstructions finished")
	}()
	return d.base.GetInstructions(ctx, userID, dialogID, limit)
}

// GetInstructionsByID implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) GetInstructionsByID(ctx context.Context, userID *entity.UserID, dialogID *entity.DialogID, instructionID *entity.InstructionID, offsetType entity.InstructionOffserType, limit uint64) (instructions []*entity.Instruction, err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling GetInstructionsByID")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: GetInstructionsByID finished")
	}()
	return d.base.GetInstructionsByID(ctx, userID, dialogID, instructionID, offsetType, limit)
}

// ReadAllMessagesBeforeAndIncl implements apientity.DialogModel
func (d *LoggingDialogModelDecorator) ReadAllMessagesBeforeAndIncl(ctx context.Context, userID *entity.UserID, dialogID *entity.DialogID, messageID *entity.MessageID) (err error) {

	d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: calling ReadAllMessagesBeforeAndIncl")
	defer func() {
		if err != nil {
			d.logger.ErrorContext(ctx, "", zap.NamedError("public api error", err))
		}
		d.logger.InfoContext(ctx, "LoggingDialogModelDecorator: ReadAllMessagesBeforeAndIncl finished")
	}()
	return d.base.ReadAllMessagesBeforeAndIncl(ctx, userID, dialogID, messageID)
}
